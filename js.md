对 this 的了解  
this 指向：this 总是指向函数的直接调用者
普通函数，定时器函数，立即执行函数 this 指向 window
构造函数中 this 指向实例对象
对象方法中 this 指向该方法所属对象
事件绑定方法中 this 指向绑定事件对象（dom 元素）

箭头函数的 this  
箭头函数没有自己的 this，它的 this 是其所在上下文中的 this，因为没有 this，所以箭头函数不能使用 new 调用

0.1+0.2 不等于 0.3？  
计算机在把 0.1 转换为二进制的时候出现了无限循环，十进制的 0.1 无法在计算机中以二进制的形式精确表示，只能舍弃一定的精确度；0.1 在计算机中保存的只能是一个近似于 0.1 的值，所以就出现了误差

箭头函数和普通函数的区别  
箭头函数不能作为构造函数使用（不能 new）
箭头函数没有自己的 this，它捕捉自己所在上下文中的 this
箭头函数的 this 不能用 call，bind，apply 改变

dom 事件流是什么  
事件流又称事件传播，指的是从页面中接受事件的顺序

事件冒泡  
事件从页面中最具体的素开始接受，逐渐向上传播到较为不具体的元素
例子：子盒子 -> 父盒子 -> html -> document

事件捕获  
不太具体的节点（元素）最先接受到事件，最具体的节点最后接受到事件
例子：documen -> html -> 父盒子 -> 子盒子

事件流顺序  
事件捕获 -> 目标事件 -> 事件冒泡

什么是事件委托  
利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件（给父元素绑定某一个事件，就可以同时给所有子元素绑定该事件）  
优点：  
减少事件注册，节省内存占用，提升性能；适合动态添加子元素的情况  
缺点：  
某些事件（focus, blur）没有事件冒泡，无法实现事件委托

---

20260112

js 有哪些数据类型

js 判断数据类型有哪些方法
typeof，instanceof，Object.prototype.toString.call

作用域和作用域链

原型和原型链

js 如何实现继承

变量提升，暂时性死区

闭包  
一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）  
场景：私有变量（eg：节流防抖）

this 指向

call, apply, bind

节流，防抖

深拷贝浅拷贝

ES6 新特性

箭头函数

new 一个对象的具体过程

promise.all promise.race promise.allSettled  
Promise.all：全部成功才成功，一个失败就立即失败
Promise.allSettled：不管成功失败，都等全部完成

async/await 相关

event loop，宏任务，微任务

垃圾回收

0.1+0.2 不等于 0.3 的原因

事件冒泡，事件捕获，事件流，事件委托

ts interface，type 区别  
第一，扩展性不同：Interface 通过 extends 继承，支持声明合并（同名接口自动合并）。Type 通过 & 交叉类型扩展，但不能合并。  
第二，设计目标不同：Interface 强调契约，适合定义对象形状和类实现；Type 是类型别名，适合定义联合类型、元组等复杂类型。  
第三，使用场景不同：
必须用 Interface 的场景：类实现（implements）、扩展第三方库类型  
必须用 Type 的场景：联合类型（'a' | 'b'）、元组、映射类型、条件类型  
对象类型优先用 Interface，复杂类型用 Type，组件 Props 根据复杂度选择。”

ts 泛型
