==和===的区别？
==判断相等，===判断严格相等/全等
==只判断数据的值是否相等，===先判断数据的类型是否相同，再判断数据的值是否相等

==判断规则：
两个基本数据类型比较：如果两个基本数据类型不同，会先把它们转换成数值类型，再进行比较
基本数据类型和引用数据类型比较：先把对象转换成原始值，再进行比较
两个引用类型比较：判断两者的引用地址是否相同
===判断规则：
先判断两者类型，只要类型不一致，直接返回false，
类型相同的前提下，再判断值是否相等

尽量使用===，因为==不严谨
使用==的情况：


js运行原理：
JIT 运行时编译
js执行过程：js》抽象语法树AST》字节码》机器码
解析器将js代码解析成AST抽象语法树
解释器将AST解释为字节码
编译器将字节码编译为机器代码
计算机运行机器代码

解释变量提升
所用变量声明语句，都会被提升到当前作用域的最前面（头部）

闭包及其作用
闭包：函数+函数内部可被访问的变量
作用：
实现私有变量
延长变量作用域

作用域链
内部函数作用域=》外层函数作用域变量=》全局作用域变量
内部上下文含有对外部上下文的引用，外部上下文含有对全局上下文的引用，可以通过这个引用访问外部上下文中的变量。这样的一个层层递进的引用关系就形成了作用域链

js数据类型
原始数据类型：
string
number
boolean 
undefined 不存在
null 空值
symbol
bigint
引用数据类型：Object

对原型链的理解
访问一个对象属性或方法时，查找的顺序
对象》原型对象》原型对象的原型》。。。》Object
__proto__（原型/原型链）的作用在于为对象成员查找机制提供了一个路线

类型转换
可能出现类型转换的情况
if语句
逻辑语句
数学运算
==
类型转化规则较复杂

判断是否是数组
Array.isArray()

对this的了解
this指向：this总是指向函数的直接调用者
普通函数，定时器函数，立即执行函数 this指向window
构造函数中 this指向实例对象
对象方法中 this指向该方法所属对象
事件绑定方法中 this指向绑定事件对象（dom元素）

箭头函数的this 
箭头函数没有自己的this，它的this是其所在上下文中的this，因为没有this，所以箭头函数不能使用new调用

构造函数new一个对象实例过程
生成一个新对象
让this指向这个对象
执行构造函数中的的代码，给该对象添加属性和方法
返回该对象

async/await是什么
async用于声明异步函数
await后面跟着一个Promise，异步函数会在这个Promise运行中暂停，直到其运行结束才继续运行
异步函数的好处（相比于传统Promise的优势）：
代码读起来更加同步，同步写法，更加优雅
错误处理友好，可使用成熟的try- catch
调试友好

js的参数是按什么方式传递的
基本数据类型  按值传递 ；基本类型存储在栈里面
复杂数据类型 按引用传递；复杂数据类型存储在堆里面，引用存放在栈里

js中如何实现不可变对象
深克隆
immutable.js
immer

js垃圾回收是怎么做的
什么是垃圾回收：
释放掉程序中不会再使用的变量或对象
垃圾回收方法：
引用计数
标记清除（最常用）
《JavaScript高级程序设计》：
引用计数：垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记
方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。
标记清除：其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用
值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。

js对象{}、null、[]的区别

{}是一个不完全空对象，原型链上有Object；null为原型链顶端，因此Object.prototype.__proto__===null为true。
null是完全空对象，原型链也没有。
[]原型链上还比{}多一个Array。
注：在转化布尔值时，对于对象而言，只有null转为false，其他的都为true，因此，一定要注意[]、{}都会被转为true。
在后端传递数据过来进行判断时，为数组时判断数组的长度，为对象时用if(Object.keys(obj).length){}，判断对象属性数组长度。
如果可能传过来null，也有可能传过来数组，并且不希望空数组执行语句，则可以if(res && res.length){}，res和res.length位置不能换，如果为null，则直接返回null，后面的res.length不执行，从而不报错，如果为[]，则res.length为0，返回0，也将空数组去除了。

0.1+0.2不等于0.3？
计算机在把0.1转换为二进制的时候出现了无限循环，十进制的0.1无法在计算机中以二进制的形式精确表示，只能舍弃一定的精确度；0.1在计算机中保存的只能是一个近似于0.1的值，所以就出现了误差


宏任务和微任务

执行代码的顺序：微任务>dom渲染>宏任务

symbol数据类型作用是什么？什么时候用symbol？
symbol表示独一无二的值
使用场景：定义对象唯一的属性名，由于每一个symbol的值都是不相等的，所以symbol作为对象的属性名可以保证属性名不重复


js异步解决方案发展历程
回调函数 缺点：回调地狱，没有try catch捕捉错误
promise 缺点：错误需要通过回调函数来捕获
Async/await 缺点：相比起promise 写法更加优雅同步

对象和数组实现深浅拷贝
对象浅拷贝：Object.assign()
数组深拷贝：slice()
深拷贝：1.JSON.parse(JSON.stringify())（不能处理函数）	2.手写递归实现深拷贝

对es6的理解（我常用的es6新语法）
模板字符串
箭头函数
for in
promise
解构赋值 扩展运算
let const 块级作用域
module 模块概念

什么是纯函数？纯函数好处
纯函数：对于给定的参数，永远只返回相同的值
纯函数好处：简单，没有副作用，便于调试（单元测试）
什么是副作用：函数会影响函数外的值，函数外的值会影响函数内的值

箭头函数和普通函数的区别
箭头函数不能作为构造函数使用（不能new）
箭头函数没有自己的this，它捕捉自己所在上下文中的this
箭头函数的this不能用call，bind，apply改变

dom事件流是什么
事件流又称事件传播，指的是从页面中接受事件的顺序

事件冒泡
事件从页面中最具体的素开始接受，逐渐向上传播到较为不具体的元素
例子：子盒子》父盒子》html》document

哪些事件不支持冒泡


事件捕获
不太具体的节点（元素）最先接受到事件，最具体的节点最后接受到事件
例子：documen》html》父盒子》子盒子

事件流顺序
事件捕获》目标事件》事件冒泡

什么是事件委托
利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件（给父元素绑定某一个事件，就可以同时给所有子元素绑定该事件）
优点：
减少事件注册，节省内存占用，提升性能；适合动态添加子元素的情况
缺点：
某些事件（focus, blur）没有事件冒泡，无法实现事件委托

