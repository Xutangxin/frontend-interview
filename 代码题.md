js 实现 new：

```js
function _new(constructor, ...args) {
  // 1. 创建空obj，把该对象的原型指向构造函数的prototype
  const obj = Object.create(constructor.prototype);

  // 2. 将构造函数里的 this 绑定到 obj，并执行
  const res = constructor.apply(obj, args);

  // 3. 若构造函数显式返回了对象/函数，则优先返回它；否则返回 obj
  return res !== null && (typeof res === "object" || typeof res === "function")
    ? res
    : obj;
}
```

深拷贝：

```js
function cloneDeep(target) {
  if (typeof target === "object") {
    let cloneTarget = Array.isArray(target) ? [] : {};
    for (const key in target) {
      cloneTarget[key] = cloneDeep(target[key]);
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

节流：

```js
function throttle(fn, delay) {
  let lastTime = 0;
  return function () {
    let nowTime = Date.now();
    if (nowTime - lastTime > delay) {
      fn.apply(this);
      lastTime = Date.now();
    }
  };
}
```

防抖：

```js
function debounce(fn, delay) {
  let timer = null;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this);
    }, delay);
  };
}
```

instanceof:

```js
function _instanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}
```

eventBus:  
简陋版：

```js
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, fn) {
    this.events[event] = fn;
  }

  emit(event) {
    if (this.events[event]) {
      let fn = this.events[event];
      fn();
    }
  }

  off(event) {
    if (this.events[event]) {
      delete this.events[event];
    }
  }

  once(event, fn) {
    this.on(event, fn);
    this.emit(event);
    this.off(event);
  }
}
```

call 实现：

```js
Function.prototype.myCall = function (context, ...args) {
  context = context || window;
  let fn = Symbol();
  context[fn] = this;
  let res = context[fn](...args);
  delete context[fn];
  return res;
};
```

apply:

```js
Function.prototype.myApply = function (obj, args) {
  const fnKey = Symbol("fn");
  obj[fnKey] = this;

  const res = Array.isArray(args) ? obj[fnKey](...args) : obj[fnKey]();

  delete obj[fnKey];

  return res;
};
```

bind:

```js
Function.prototype.myBind = function () {
  let self = this;
  let args = [...arguments];
  let obj = args.shift();

  return function () {
    return self.apply(obj, args);
  };
};
```

js解析url参数:

```js
function parseUrlParams(url) {
  const searchParams = window.location.search.substring(1).split("&");
  const params = {};
  searchParams.forEach((param) => {
    const [key, value] = param.split("=");
    params[key] = decodeURIComponent(value);
  });
  return params;
}

// 或者
const params = Object.fromEntries(new URLSearchParams(location.search));
// Object.fromEntries() 静态方法将键值对列表转换为一个对象。
console.log(params);
```

LRU 缓存：

```js
class LRUCache {
  constructor(lenght) {
    this.length = lenght; // 存储长度
    this.cache = new Map(); // 存储数据
  }
  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return -1;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.length) {
      const delKey = this.cache.keys().next().value;
      this.cache.delete(delKey);
    }
  }
}
```

列表转树：

```js
function listToTree(list) {
  const tree = [];
  const map = {};
  list.forEach((item) => {
    map[item.id] = {
      ...item,
      children: [],
    };
  });
  list.forEach((item) => {
    if (map[item.parentId]) {
      map[item.parentId].children.push(item);
    } else {
      tree.push(item);
    }
  });
  return tree;
}
```

并发控制：

```js
function limitRequest(urls, limit) {
  return new Promise((resolve) => {
    if (urls.length === 0) {
      resolve([]);
      return;
    }

    const results = [];
    let index = 0; // 下一个要处理的任务索引
    let count = 0; // 已完成的任务数量

    // 核心递归函数
    async function request() {
      if (index === urls.length) return;

      // 1. 记录当前任务的索引并更新全局指针
      const i = index;
      const url = urls[index];
      index++;

      console.log(`开始请求: ${url}`);

      try {
        // 2. 执行异步请求（模拟 fetch）
        const res = await fetch(url);
        results[i] = res;
      } catch (err) {
        results[i] = err;
      } finally {
        // 3. 任务完成后，已完成计数器自增
        count++;

        // 4. 判断是否全部完成
        if (count === urls.length) {
          resolve(results);
        } else {
          // 5. 关键：只要还有任务，就继续开启下一个递归
          request();
        }
      }
    }

    // 6. 初始启动：开启 limit 个并发连接
    const initialLimit = Math.min(limit, urls.length);
    for (let i = 0; i < initialLimit; i++) {
      request();
    }
  });
}

// --- 测试代码 ---
const urls = Array.from({ length: 10 }, (_, i) => `url-${i}`);
limitRequest(urls, 3).then((res) => {
  console.log("所有任务完成:", res);
});
```

Promise.all:

```js
Promise.myAll = function (promises) {
  return new Promise((resolve, reject) => {
    // 1. 判断是否为数组（健壮性检查）
    if (!Array.isArray(promises)) {
      return reject(new TypeError("Arguments must be an array"));
    }

    const results = [];
    let count = 0; // 记录已完成的任务数量
    const len = promises.length;

    // 2. 特殊情况：如果输入为空数组，直接返回空结果
    if (len === 0) {
      resolve([]);
      return;
    }

    // 3. 遍历数组
    for (let i = 0; i < len; i++) {
      // 4. 使用 Promise.resolve 确保非 Promise 值也能正常处理
      Promise.resolve(promises[i])
        .then((res) => {
          // 5. 关键：不能用 results.push，必须用索引赋值来保证顺序
          results[i] = res;
          count++;

          // 6. 只有当全部完成后才 resolve
          if (count === len) {
            resolve(results);
          }
        })
        .catch((err) => {
          // 7. 只要有一个失败，整体立即 reject
          reject(err);
        });
    }
  });
};
```
