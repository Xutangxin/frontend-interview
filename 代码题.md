js 实现 new：

```js
function _new(constructor, ...args) {
  // 1. 创建空obj，把该对象的原型指向构造函数的prototype
  const obj = Object.create(constructor.prototype);

  // 2. 将构造函数里的 this 绑定到 obj，并执行
  const res = constructor.apply(obj, args);

  // 3. 若构造函数显式返回了对象/函数，则优先返回它；否则返回 obj
  return res !== null && (typeof res === "object" || typeof res === "function")
    ? res
    : obj;
}
```

深拷贝：

```js
function cloneDeep(target) {
  if (typeof target === "object") {
    let cloneTarget = Array.isArray(target) ? [] : {};
    for (const key in target) {
      cloneTarget[key] = cloneDeep(target[key]);
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

节流：

```js
function throttle(fn, delay) {
  let lastTime = 0;
  return function () {
    let nowTime = Date.now();
    if (nowTime - lastTime > delay) {
      fn.apply(this);
      lastTime = Date.now();
    }
  };
}
```

防抖：

```js
function debounce(fn, delay) {
  let timer = null;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this);
    }, delay);
  };
}
```

instanceof:

```js
function _instanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}
```

eventBus:  
简陋版：

```js
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, fn) {
    this.events[event] = fn;
  }

  emit(event) {
    if (this.events[event]) {
      let fn = this.events[event];
      fn();
    }
  }

  off(event) {
    if (this.events[event]) {
      delete this.events[event];
    }
  }

  once(event, fn) {
    this.on(event, fn);
    this.emit(event);
    this.off(event);
  }
}
```

call 实现：

```js
Function.prototype.myCall = function (context, ...args) {
  context = context || window;
  let fn = Symbol();
  context[fn] = this;
  let res = context[fn](...args);
  delete context[fn];
  return res;
};
```

apply:

```js
Function.prototype.myApply = function (obj, args) {
  const fnKey = Symbol("fn");
  obj[fnKey] = this;

  const res = Array.isArray(args) ? obj[fnKey](...args) : obj[fnKey]();

  delete obj[fnKey];

  return res;
};
```

bind:

```js
Function.prototype.myBind = function () {
  let self = this;
  let args = [...arguments];
  let obj = args.shift();

  return function () {
    return self.apply(obj, args);
  };
};
```

js解析url参数:

```js
function parseUrlParams(url) {
  const searchParams = window.location.search.substring(1).split("&");
  const params = {};
  searchParams.forEach((param) => {
    const [key, value] = param.split("=");
    params[key] = decodeURIComponent(value);
  });
  return params;
}

// 或者
const params = Object.fromEntries(new URLSearchParams(location.search));
// Object.fromEntries() 静态方法将键值对列表转换为一个对象。
console.log(params);
```

LRU 缓存：

```js
class LRUCache {
  constructor(lenght) {
    this.length = lenght; // 存储长度
    this.cache = new Map(); // 存储数据
  }
  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return -1;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);
    if (this.cache.size > this.length) {
      const delKey = this.cache.keys().next().value;
      this.cache.delete(delKey);
    }
  }
}
```
