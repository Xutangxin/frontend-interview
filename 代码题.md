js 实现 new：

```js
function _new(constructor, ...args) {
  // 1. 创建空对象，把原型指向 ctor.prototype
  const obj = Object.create(constructor.prototype);

  // 2. 将构造函数里的 this 绑定到 obj，并执行
  const ret = ctor.apply(obj, args);

  // 3. 若构造函数显式返回了对象/函数，则优先返回它；否则返回 obj
  return ret !== null && (typeof ret === "object" || typeof ret === "function")
    ? ret
    : obj;
}
```

深拷贝：

```js
function cloneDeep(target) {
  if (typeof target === "object") {
    let cloneTarget = Array.isArray(target) ? [] : {};
    for (const key in target) {
      cloneTarget[key] = cloneDeep(target[key]);
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

节流：

```js
function throttle(fn, delay) {
  let lastTime = 0;
  return function () {
    let nowTime = Date.now();
    if (nowTime - lastTime > delay) {
      fn.apply(this);
      lastTime = Date.now();
    }
  };
}
```

防抖：

```js
function debounce(fn, delay) {
  let timer = null;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this);
    }, delay);
  };
}
```

instanceof:

```js
function _instanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}
```

eventBus:  
简陋版：

```js
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, fn) {
    this.events[event] = fn;
  }

  emit(event) {
    if (this.events[event]) {
      let fn = this.events[event];
      fn();
    }
  }

  off(event) {
    if (this.events[event]) {
      delete this.events[event];
    }
  }

  once(event, fn) {
    this.on(event, fn);
    this.emit(event);
    this.off(event);
  }
}
```

call 实现：

```js
Function.prototype.myCall = function (context, ...args) {
  context = context || window;
  let fn = Symbol();
  context[fn] = this;
  let res = context[fn](...args);
  delete context[fn];
  return res;
};
```

apply:

```js
Function.prototype.myApply = function () {
  let args = [...arguments];
  let obj = args.shift();
  let self = this;
  obj["fn"] = self;

  let res;
  if (args.length) res = obj["fn"](...args[0]);
  else res = obj["fn"]();
  delete obj["fn"];
  return res;
};
```

bind:

```js
Function.prototype.myBind = function () {
  let self = this;
  let args = [...arguments];
  let obj = args.shift();

  return function () {
    return self.apply(obj, args);
  };
};
```
