浏览器是如何运作的：
浏览器是个多进程结构，
1. 浏览器进程:控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作2.
2. 缓存进程
3. 网络进程  发起网络请求
4. 渲染器进程    渲染Tab  有可能会为每个标签页是一个渲染进程
5. GPU进程  渲染
6. 插件进程    内置插件

下面说下渲染进程的过程
1. 浏览器通过网络请求后获取html数据，通过tcp传给渲染器进程
2. DOM - 主线程将html解析构造DOM树
3. style - 样式计算
4. layoutTree - dom+style 根据dom树和样式生成layoutTree
5. paint -绘制  通过遍历 Layout Tree生成绘制顺序表
6. laryer - 布局  然后根据主进程将layoutTree 和绘制信息表传给合成器线程
7. 合成器线程  - 将得到的信息分图层分成更小的图块
8. 栅格线程    -    将更小的图块进行栅格化raster，返还给合成器线程draw quads图块信息  存储在GPU中
9. frame 合成器将栅格线程返回的图块合成帧交给浏览器进程
10. 浏览器进程  收到一帧的图像后传给GPU进行渲染

重排和重绘
重排：
当改变dom的属性（宽高，字体大小）时，会重新进行样式计算，会重新布局和绘制
重绘：
当改变颜色时，只会发生样式计算和绘制(layer)
改善手段：
requestAnimationFrame()
会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程
Fiber
react利用浏览器的空闲时间做优化
Transform
会直接运行合成器线程，所以不会感染主线程的渲染
在移动端使用3d转换可以优化性能（如果设备有3d加速引擎 GPU 可以提高性能 , 2d转换是无法调用GPU，2G是靠的CPU）


常见浏览器内核：


浏览器是如何渲染页面的 ：
获取html文件，解析生成dom  tree
解析css，生成style rules
将dom tree 和styel rules 合称为render tree
布局，为每个节点分配位置（确切位置和大小）
绘制，遍历render tree，将元素绘制出来

浏览器如何解析css选择器：
从右往左匹配，这样性能更好，可以一开始就筛选掉不匹配的最优节点（叶子节点）


浏览器重绘和重排：
重绘：某些元素的外观被改变
重排：重新生成布局和排列元素，影响性能和用户体验最大
重排一定有重绘，重绘不一定有重排
如何触发重绘和重排：
dom节点的增删改
dom节点动画
用户行为：调整窗口大小，滚动等
。。。。。。。
如何避免重绘或重排：
集中改变样式

什么是同源策略：
同协议，同域名，同端口
如何解决跨域问题：
jsonp
跨域资源共享CORS
使用反向代理nginx


V8引擎是如何运行JS代码的：

js调用栈

从输入url到页面加载的过程：
dns把域名解析为ip地址
发起tcp三次握手建立连接
连接建立后发送http请求
服务器响应请求，浏览器获取html代码
浏览器收到html代码，开始渲染
浏览器解析html为dom tree
浏览器解析css为css tree
浏览器将dom tree 和css tree合并为 render tree，并渲染
加载并执行js代码


如何提高前端页面性能
图片懒加载
减少dom元素数量
尽量减少http请求
精灵图（雪碧图）技术，减少对服务器的请求
图片用base64
延迟载入路由，延迟载入组件
使用gulp，webpack等相关工具压缩html，js代码
尽量避免重绘和重排（回流）
避免频繁操作样式
使用事件委托，减少事件注册，减小内存占用，还可以实现元素动态绑定
节流和防抖


前端安全问题
XSS 跨站脚本攻击，一种代码注入方式
iframe滥用（iframe内容一般来自第三方，通常情况下不由我们控制）
CSRF 跨站点请求伪造
恶意第三方库，开发框架被植入恶意代码

tcp三次握手
三次握手目的：确认双方的接受和发送能力是否正常
第一次握手：客户端发送报文给服务端（服务端可以确认自己可以收到客户端的报文）
第二次握手：服务端收到报文之后，应答一个报文（客户端可以确认服务端收到了自己的报文，且自己可以接受服务端发送的报文）
第三次握手：客户端收到服务端发送的报文后，回应一个报文（服务端可以确认客户端收到了自己的报文）服务端收到报文后，三次握手建立完成
三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：
第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

TCP和UDP的区别
tcp是面向连接的, udp是无连接的(发送数据前不需要连接)
tcp提供可靠的服务(无差错,不丢失,不重复,按序到达), udp尽最大努力交付(不可靠交付)
tcp面向字节流, udp面向报文
tcp只支持1对1, udp支持1对多
tcp适用于要求可靠传输的应用(文件传输), udp适用于实时通信应用(视频会议,直播等)

http2.0 新特性
二进制分帧
多路复用/连接共享
头部压缩
请求优先级
服务端推送

浏览器缓存和http缓存
浏览器缓存：
memory cache
这类缓存是暂时性的，关闭了浏览器，缓存空间就被释放了
这类缓存比较高效，但是能使用的空间比较小
disk cache
相比于memory cache 时效较长
http缓存：
强缓存，协商缓存

dns域名解析过程：
输入域名后，先查找本地主机的域名服务器，域名服务器先查找自己数据库中的数据
如果没有，就像上级域名服务器中查找，依此类推
域名的查找最多追溯到根域名服务器，到了这一步，肯定能查找到域名对应的ip地址
域名服务器自身也会进行一些缓存，把曾经访问过的域名和对应的ip地址保存起来，加速查找过程，方便下次的查找

http报文的请求有哪几个部分
请求行
请求方法
请求头
请求数据
空行
响应报文（状态行，消息报头，响应正文）

cookie放哪⾥，cookie能做的事情和存在的价值
cookie放在请求头中
cookie由服务端发送给客户端，客户端向服务端发送请求的时候会带上cookie，让服务端可以记录客户端状态
cookie用途：1.会话状态管理（记录用户登录状态等信息） 2.个性化设置 3.浏览器状态跟踪

cookie和session区别
cookie存放在客户端 session存放在服务端
单个cookie存储容量为4k  session没有上限
cookie对客户端可见的 session是透明的
cookie和session有效期不同
cookie支持跨域访问 session不支持跨域访问

浏览器缓存
缓存位置：
service worker
memory cache
disk cache
push cache
缓存机制：
强缓存：
不会向服务器发送请求，直接从缓存中读取数据
协商缓存
强缓存过期后，浏览器携带缓存标识向服务端发送请求，由服务端决定是否使用缓存

强缓存优先于协商缓存进行，若强缓存生效则直接使用强缓存，若强缓存失效则进行协商缓存，协商缓存中由服务器决定是否使用缓存。
协商缓存生效，服务端返回304和not modified（资源无更新），继续使用缓存；协商缓存失效，返回200（资源更新），浏览器将新的结果和缓存标识存入浏览器缓存中。

CORS（跨域资源共享）过程：
浏览器发送cors请求，在头信息加上一个Origin字段，该字段用来说明请求来自于哪个源（协议+域名+端口），服务器根据这个值来决定是否同意请求；
服务器收到请求后，会根据Origin判断源是否在许可范围内。如果在许可范围内，服务端就在回应的http回应中添加Access-Control-Allow-Origin字段，在该字段中回发相应的源信息；如果不在许可范围内，服务端返回一个正常的htttp回应
浏览器发现没回应的头信息没有Access-Control-Allow-Origin这个字段（或者内容不匹配），就知道出错了，从而抛出异常
